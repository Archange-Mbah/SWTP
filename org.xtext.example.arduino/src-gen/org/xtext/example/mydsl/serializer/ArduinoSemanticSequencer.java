/*
 * generated by Xtext 2.32.0
 */
package org.xtext.example.mydsl.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.example.mydsl.arduino.ArduinoPackage;
import org.xtext.example.mydsl.arduino.Model;
import org.xtext.example.mydsl.arduino.behavior;
import org.xtext.example.mydsl.arduino.component;
import org.xtext.example.mydsl.arduino.component_state;
import org.xtext.example.mydsl.arduino.components;
import org.xtext.example.mydsl.arduino.connection;
import org.xtext.example.mydsl.arduino.max;
import org.xtext.example.mydsl.arduino.min;
import org.xtext.example.mydsl.arduino.state;
import org.xtext.example.mydsl.arduino.transition;
import org.xtext.example.mydsl.arduino.transition_effect;
import org.xtext.example.mydsl.arduino.wiring;
import org.xtext.example.mydsl.services.ArduinoGrammarAccess;

@SuppressWarnings("all")
public class ArduinoSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private ArduinoGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == ArduinoPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ArduinoPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case ArduinoPackage.BEHAVIOR:
				sequence_behavior(context, (behavior) semanticObject); 
				return; 
			case ArduinoPackage.COMPONENT:
				sequence_component(context, (component) semanticObject); 
				return; 
			case ArduinoPackage.COMPONENT_STATE:
				sequence_component_state(context, (component_state) semanticObject); 
				return; 
			case ArduinoPackage.COMPONENTS:
				sequence_components(context, (components) semanticObject); 
				return; 
			case ArduinoPackage.CONNECTION:
				sequence_connection(context, (connection) semanticObject); 
				return; 
			case ArduinoPackage.MAX:
				sequence_max(context, (max) semanticObject); 
				return; 
			case ArduinoPackage.MIN:
				sequence_min(context, (min) semanticObject); 
				return; 
			case ArduinoPackage.STATE:
				sequence_state(context, (state) semanticObject); 
				return; 
			case ArduinoPackage.TRANSITION:
				sequence_transition(context, (transition) semanticObject); 
				return; 
			case ArduinoPackage.TRANSITION_EFFECT:
				sequence_transition_effect(context, (transition_effect) semanticObject); 
				return; 
			case ArduinoPackage.WIRING:
				sequence_wiring(context, (wiring) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     (components+=components* connection=connection behavior=behavior)
	 * </pre>
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     behavior returns behavior
	 *
	 * Constraint:
	 *     (states+=state* transitions+=transition*)
	 * </pre>
	 */
	protected void sequence_behavior(ISerializationContext context, behavior semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     component returns component
	 *
	 * Constraint:
	 *     (components=[components|ID] name=ID)
	 * </pre>
	 */
	protected void sequence_component(ISerializationContext context, component semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ArduinoPackage.Literals.COMPONENT__COMPONENTS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArduinoPackage.Literals.COMPONENT__COMPONENTS));
			if (transientValues.isValueTransient(semanticObject, ArduinoPackage.Literals.COMPONENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArduinoPackage.Literals.COMPONENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComponentAccess().getComponentsComponentsIDTerminalRuleCall_1_0_1(), semanticObject.eGet(ArduinoPackage.Literals.COMPONENT__COMPONENTS, false));
		feeder.accept(grammarAccess.getComponentAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     component_state returns component_state
	 *
	 * Constraint:
	 *     name=ID
	 * </pre>
	 */
	protected void sequence_component_state(ISerializationContext context, component_state semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ArduinoPackage.Literals.COMPONENT_STATE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArduinoPackage.Literals.COMPONENT_STATE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComponent_stateAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     components returns components
	 *
	 * Constraint:
	 *     (name=ID connectors+=connectors* component_state+=component_state*)
	 * </pre>
	 */
	protected void sequence_components(ISerializationContext context, components semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     connection returns connection
	 *
	 * Constraint:
	 *     (component+=component* wiring+=wiring*)
	 * </pre>
	 */
	protected void sequence_connection(ISerializationContext context, connection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     max returns max
	 *
	 * Constraint:
	 *     name=ID
	 * </pre>
	 */
	protected void sequence_max(ISerializationContext context, max semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ArduinoPackage.Literals.MAX__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArduinoPackage.Literals.MAX__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMaxAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     min returns min
	 *
	 * Constraint:
	 *     name=ID
	 * </pre>
	 */
	protected void sequence_min(ISerializationContext context, min semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ArduinoPackage.Literals.MIN__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArduinoPackage.Literals.MIN__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMinAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     state returns state
	 *
	 * Constraint:
	 *     (name=ID component=[component|ID] component_state=[component_state|FQN])
	 * </pre>
	 */
	protected void sequence_state(ISerializationContext context, state semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ArduinoPackage.Literals.STATE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArduinoPackage.Literals.STATE__NAME));
			if (transientValues.isValueTransient(semanticObject, ArduinoPackage.Literals.STATE__COMPONENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArduinoPackage.Literals.STATE__COMPONENT));
			if (transientValues.isValueTransient(semanticObject, ArduinoPackage.Literals.STATE__COMPONENT_STATE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArduinoPackage.Literals.STATE__COMPONENT_STATE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStateAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getStateAccess().getComponentComponentIDTerminalRuleCall_2_0_1(), semanticObject.eGet(ArduinoPackage.Literals.STATE__COMPONENT, false));
		feeder.accept(grammarAccess.getStateAccess().getComponent_stateComponent_stateFQNParserRuleCall_5_0_1(), semanticObject.eGet(ArduinoPackage.Literals.STATE__COMPONENT_STATE, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     transition_effect returns transition_effect
	 *
	 * Constraint:
	 *     microseconds=INT
	 * </pre>
	 */
	protected void sequence_transition_effect(ISerializationContext context, transition_effect semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ArduinoPackage.Literals.TRANSITION_EFFECT__MICROSECONDS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArduinoPackage.Literals.TRANSITION_EFFECT__MICROSECONDS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTransition_effectAccess().getMicrosecondsINTTerminalRuleCall_3_0(), semanticObject.getMicroseconds());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     transition returns transition
	 *
	 * Constraint:
	 *     (src_state=[state|ID]? tar_state=[state|ID] transition_effect=transition_effect?)
	 * </pre>
	 */
	protected void sequence_transition(ISerializationContext context, transition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     wiring returns wiring
	 *
	 * Constraint:
	 *     (src=[component|ID] src_port=connectors tar=[component|ID] tar_port=connectors)
	 * </pre>
	 */
	protected void sequence_wiring(ISerializationContext context, wiring semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ArduinoPackage.Literals.WIRING__SRC) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArduinoPackage.Literals.WIRING__SRC));
			if (transientValues.isValueTransient(semanticObject, ArduinoPackage.Literals.WIRING__SRC_PORT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArduinoPackage.Literals.WIRING__SRC_PORT));
			if (transientValues.isValueTransient(semanticObject, ArduinoPackage.Literals.WIRING__TAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArduinoPackage.Literals.WIRING__TAR));
			if (transientValues.isValueTransient(semanticObject, ArduinoPackage.Literals.WIRING__TAR_PORT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArduinoPackage.Literals.WIRING__TAR_PORT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWiringAccess().getSrcComponentIDTerminalRuleCall_0_0_1(), semanticObject.eGet(ArduinoPackage.Literals.WIRING__SRC, false));
		feeder.accept(grammarAccess.getWiringAccess().getSrc_portConnectorsParserRuleCall_2_0(), semanticObject.getSrc_port());
		feeder.accept(grammarAccess.getWiringAccess().getTarComponentIDTerminalRuleCall_4_0_1(), semanticObject.eGet(ArduinoPackage.Literals.WIRING__TAR, false));
		feeder.accept(grammarAccess.getWiringAccess().getTar_portConnectorsParserRuleCall_6_0(), semanticObject.getTar_port());
		feeder.finish();
	}
	
	
}
